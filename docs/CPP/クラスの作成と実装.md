## 参考
[cpp](https://rinatz.github.io/cpp-book/ch07-05-constructors/)
[用語](https://wa3.i-3-i.info/word13647.html)
[RAII](https://qiita.com/wx257osn2/items/e2e3bcbfdd8bd02872aa)

## 1. クラスの宣言と定義
- 宣言は通常ヘッダファイル(.h)、定義は実装ファイル(.cpp)で行う
- **この分離でコードの管理が簡単になる**

## 2. メンバ変数の設計
- 注意点
	1. 適切なデータ型の選択
	2. アクセス修飾子の適切な使用
		- private: クラス内部からのみアクセス可能
		- protected: 派生クラスからもアクセス可能
		- public: どこからでもアクセス可能
	3. const修飾子の活用

## 3. コンストラクタの実装
- コンストラクタはオブジェクトの初期化担当
	- デフォルトコンストラクタ
		値を1つも受け取らないコンストラクタ
		~~~cpp
		class_name default_constructor
		~~~

	- コピーコンストラクタ
		そのクラスの参照だけを受け取るコンストラクタ
		~~~cpp
		class Copyable { 
		public: 
		// デフォルトコンストラクタ
		Copyable(); 
		// コピーコンストラクタ 
		Copyable(const Copyable& c); 
		};
		~~~

## 4. デストラクタの実装
- デストラクタはオブジェクトが破棄される際のカラーアップ処理担当
- Javaだとガベージコレクタがいてこの時（メモリ解放時）にファアナライザが呼ばれる、cppだとガベージコレクタがいないが、デストラクタはファアナライザと似てはなるものですよ。
- [参考](https://wa3.i-3-i.info/word13647.html)
~~~cpp
~destructor() {
	// 処理
}
~~~

**RAIIのためを除いてデストラクタを書く機会はない**
- RAII技法が使われたリソース管理クラスをデータメンバに持つだけでそれらのデストラクタが自動的に呼び出されるから

### RAIIとは
-  Resource Acquisition Is Initializationの頭文字
- リソースの管理がプログラム記述中につきまとう
- RAII技法を実装するクラスを作るときにはただ一つのリソースのみを管理するクラスを作る
- GC(ガベージコレクション)と比較して優れた点がいくつかある
	- 解放のタイミングが明確(スコープを抜けた時)
		- スコープの終了位置によってある程度解放処理のタイミングを決めることができる
### C++におけるRAII
- [スマートポインタ](smartPointer)

- [RAII](https://qiita.com/wx257osn2/items/e2e3bcbfdd8bd02872aa)

## 5. メンバ関数の追加
- **クラスの振る舞いを定義**
- 主な関数
	- ゲッター関数
	- セッター関数
	- ユーティリティ関数
	- 状態チェック関数

## 6. インスタンス化とメモリ管理
- 可能な限りスマートポインタを使用する
- RAIIパターンを採用する
- メモリリークを防ぐためデストラクタで適切なクリーンアップを行う
- コピームーブの意味論を理解し、必要に応じて実装する

## パフォーマンスの最適化
- 不必要なコピーの回避
	値渡し -> const参照渡し
	(大きなオブジェクトの受け渡し)

- コレクション
	vectorを使用したデータ管理
	[vector](vector.md)

[return](クラス.md)